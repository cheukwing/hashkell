module MiddleendTests (middleendTests) where

import Test.Tasty
import Test.Tasty.HUnit

import Prelude hiding (EQ, LT, GT)
import Data.Either (Either(..))

import Simple.Syntax
import Middleend.Cleaner (ensureUniqueNames, ensureNoUnusedDefs)

middleendTests :: TestTree
middleendTests = testGroup "Middleend Tests"
    [ ensureUniqueNamesTests
    , ensureNoUnusedDefsTests
    ]

ensureUniqueNamesTests = testGroup "ensureUniqueNames tests"
    [ testCase "expressions with unique names are unchanged" $
        ensureUniqueNames 
            (Let [ Def "x" (Lit (LInt 1))
                 , Def "y" (Lit (LInt 2))
                 ] 
                 (Let [ Def "z" (Lit (LInt 3))
                      , Def "w" (Lit (LInt 4))
                      ] (Var "x")))
            @?=
            Let [ Def "x" (Lit (LInt 1))
                , Def "y" (Lit (LInt 2))
                ] 
                (Let [ Def "z" (Lit (LInt 3))
                     , Def "w" (Lit (LInt 4))
                     ] (Var "x"))
    , testCase "definitions with non-unique names are changed" $
        ensureUniqueNames 
            (Let [ Def "x" (Lit (LInt 1))
                 , Def "y" (Lit (LInt 2))
                 ] 
                 (Let [ Def "y" (Lit (LInt 3))
                      , Def "z" (Lit (LInt 4))
                      ] (Var "x")))
            @?=
            Let [ Def "x" (Lit (LInt 1))
                , Def "y" (Lit (LInt 2))
                ] 
                (Let [ Def "_y0" (Lit (LInt 3))
                     , Def "z" (Lit (LInt 4))
                     ] (Var "x"))
    , testCase "definitions with non-unique names and their users are changed" $
        ensureUniqueNames 
            (Let [ Def "x" (Lit (LInt 1))
                 , Def "y" (Lit (LInt 2))
                 ] 
                 (Let [ Def "y" (Lit (LInt 3))
                      , Def "z" (Lit (LInt 4))
                      ] (Var "y")))
            @?=
            Let [ Def "x" (Lit (LInt 1))
                , Def "y" (Lit (LInt 2))
                ] 
                (Let [ Def "_y0" (Lit (LInt 3))
                     , Def "z" (Lit (LInt 4))
                     ] (Var "_y0"))
    , testCase "does not change users of non-unique names in a different scope" $
        ensureUniqueNames 
            (Let [ Def "x" (Let [Def "x" (Lit (LInt 1))] (Var "x")) ] 
                (Op Add (Var "x") (Lit (LInt 2))))
            @?=
            Let [ Def "x" (Let [Def "_y0" (Lit (LInt 1))] (Var "_y0")) ] 
                (Op Add (Var "x") (Lit (LInt 2)))
    , testCase "changes names which are similar to those generated by the application" $
        ensureUniqueNames 
            (Let [ Def "_x0" (Lit (LInt 1))
                 , Def "_y0" (Lit (LInt 2))
                 ] 
                 (Let [ Def "_x1" (Lit (LInt 3))
                      , Def "_x2" (Lit (LInt 4))
                      ] (Var "_y0")))
            @?=
            Let [ Def "_y0" (Lit (LInt 1))
                , Def "_y1" (Lit (LInt 2))
                ] 
                (Let [ Def "_y2" (Lit (LInt 3))
                     , Def "_y3" (Lit (LInt 4))
                     ] (Var "_y1"))
    , testCase "changes names inside other expressions" $
        ensureUniqueNames 
            (Op Add (Var "n") (Let [ Def "x" (Let [Def "x" (Lit (LInt 1))] (Var "x")) ] 
                (Op Add (Var "x") (Lit (LInt 2)))))
            @?=
            Op Add (Var "n") (Let [ Def "x" (Let [Def "_y0" (Lit (LInt 1))] (Var "_y0")) ] 
                (Op Add (Var "x") (Lit (LInt 2))))
    ]

ensureNoUnusedDefsTests = testGroup "ensureNoUsedDefs tests"
    [ testCase "expressions with no unused defs are unchanged" $
        ensureNoUnusedDefs 
            (Let [ Def "x" (Lit (LInt 1))
                 , Def "y" (Lit (LInt 2))
                 ] 
                 (Let [ Def "z" (Lit (LInt 3))
                      , Def "w" (Lit (LInt 4))
                      ] (Op Add (Var "x") (Op Add (Var "y") (Op Add (Var "z") (Var "w"))))))
            @?=
            Let [ Def "x" (Lit (LInt 1))
                , Def "y" (Lit (LInt 2))
                ] 
                (Let [ Def "z" (Lit (LInt 3))
                     , Def "w" (Lit (LInt 4))
                     ] (Op Add (Var "x") (Op Add (Var "y") (Op Add (Var "z") (Var "w")))))
    , testCase "removes unused defs" $
        ensureNoUnusedDefs 
            (Let [ Def "x" (Lit (LInt 1))
                 , Def "y" (Lit (LInt 2))
                 ] 
                 (Let [ Def "z" (Lit (LInt 3))
                      , Def "w" (Lit (LInt 4))
                      ] (Op Add (Var "x") (Var "w"))))
            @?=
            Let [ Def "x" (Lit (LInt 1)) ] 
                (Let [ Def "w" (Lit (LInt 4)) ]
                    (Op Add (Var "x") (Var "w")))
    , testCase "removes let expressions if all expressions unused" $
        ensureNoUnusedDefs 
            (Let [ Def "x" (Lit (LInt 1))
                 , Def "y" (Lit (LInt 2))
                 ] 
                 (Let [ Def "z" (Lit (LInt 3))
                      , Def "w" (Lit (LInt 4))
                      ] (Lit (LInt 0))))
            @?= Lit (LInt 0)
    ]