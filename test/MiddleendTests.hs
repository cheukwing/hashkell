module MiddleendTests (middleendTests) where

import Test.Tasty
import Test.Tasty.HUnit

import Prelude hiding (EQ, LT, GT)
import qualified Data.Set as Set
import qualified Data.Map.Strict as Map

import Simple.Syntax
import Frontend (Cplx(..))
import Middleend.Cleaner (ensureUniqueNames, ensureNoUnusedDefs)
import Middleend.Paralleliser (parallelisationType, ParallelisationType(..), EncodingInstruction(..), createEncodingInstructionTable)
import Middleend.DependencyGraph (DType(..), DNode(..), DLit(..), DExpr(..), createDependencyGraph)

middleendTests :: TestTree
middleendTests = testGroup "Middleend Tests"
    [ ensureUniqueNamesTests
    , ensureNoUnusedDefsTests
    , parallelisationTypeTests
    , createEncodingInstructionTableTests
    , createDependencyGraphTests
    ]

ensureUniqueNamesTests = testGroup "ensureUniqueNames tests"
    [ testCase "expressions with unique names are unchanged" $
        ensureUniqueNames []
            (Let [ Def "x" (Lit (LInt 1))
                 , Def "y" (Lit (LInt 2))
                 ] 
                 (Let [ Def "z" (Lit (LInt 3))
                      , Def "w" (Lit (LInt 4))
                      ] (Var "x")))
            @?=
            ([]
            , Let [ Def "x" (Lit (LInt 1))
                , Def "y" (Lit (LInt 2))
                ] 
                (Let [ Def "z" (Lit (LInt 3))
                     , Def "w" (Lit (LInt 4))
                     ] (Var "x"))
            )
    , testCase "definitions with non-unique names are changed" $
        ensureUniqueNames []
            (Let [ Def "x" (Lit (LInt 1))
                 , Def "y" (Lit (LInt 2))
                 ] 
                 (Let [ Def "y" (Lit (LInt 3))
                      , Def "z" (Lit (LInt 4))
                      ] (Var "x")))
            @?=
            ([]
            , Let [ Def "x" (Lit (LInt 1))
                , Def "y" (Lit (LInt 2))
                ] 
                (Let [ Def "_y0" (Lit (LInt 3))
                     , Def "z" (Lit (LInt 4))
                     ] (Var "x"))
            )
    , testCase "definitions with non-unique names and their users are changed" $
        ensureUniqueNames []
            (Let [ Def "x" (Lit (LInt 1))
                 , Def "y" (Lit (LInt 2))
                 ] 
                 (Let [ Def "y" (Lit (LInt 3))
                      , Def "z" (Lit (LInt 4))
                      ] (Var "y")))
            @?=
            ([]
            , Let [ Def "x" (Lit (LInt 1))
                , Def "y" (Lit (LInt 2))
                ] 
                (Let [ Def "_y0" (Lit (LInt 3))
                     , Def "z" (Lit (LInt 4))
                     ] (Var "_y0"))
            )
    , testCase "does not change users of non-unique names in a different scope" $
        ensureUniqueNames []
            (Let [ Def "x" (Let [Def "x" (Lit (LInt 1))] (Var "x")) ] 
                (Op Add (Var "x") (Lit (LInt 2))))
            @?=
            ( [], Let [ Def "x" (Let [Def "_y0" (Lit (LInt 1))] (Var "_y0")) ] 
                (Op Add (Var "x") (Lit (LInt 2))))
    , testCase "changes names which are similar to those generated by the application" $
        ensureUniqueNames []
            (Let [ Def "_x0" (Lit (LInt 1))
                 , Def "_y0" (Lit (LInt 2))
                 ] 
                 (Let [ Def "_x1" (Lit (LInt 3))
                      , Def "_x2" (Lit (LInt 4))
                      ] (Var "_y0")))
            @?=
            ([]
            , Let [ Def "_y0" (Lit (LInt 1))
                , Def "_y1" (Lit (LInt 2))
                ] 
                (Let [ Def "_y2" (Lit (LInt 3))
                     , Def "_y3" (Lit (LInt 4))
                     ] (Var "_y1"))
            )
    , testCase "changes names inside other expressions" $
        ensureUniqueNames []
            (Op Add (Var "n") (Let [ Def "x" (Let [Def "x" (Lit (LInt 1))] (Var "x")) ] 
                (Op Add (Var "x") (Lit (LInt 2)))))
            @?=
            ([], Op Add (Var "n") (Let [ Def "x" (Let [Def "_y0" (Lit (LInt 1))] (Var "_y0")) ] 
                (Op Add (Var "x") (Lit (LInt 2)))))
    , testCase "changes names which are the same as the params" $
        ensureUniqueNames ["n", "m"]
            (Let [ Def "n" (Lit (LInt 1))
                 , Def "m" (Lit (LInt 2))
                 ] 
                 (Let [ Def "n" (Lit (LInt 3))
                      , Def "m" (Lit (LInt 4))
                      ] (Op Add (Var "n") (Var "m"))))
            @?=
            (["n", "m"]
            , Let [ Def "_y0" (Lit (LInt 1))
                , Def "_y1" (Lit (LInt 2))
                ] 
                (Let [ Def "_y2" (Lit (LInt 3))
                     , Def "_y3" (Lit (LInt 4))
                     ] (Op Add (Var "_y2") (Var "_y3")))
            )
    , testCase "changes param names which are similar to generated names" $
        ensureUniqueNames ["_x", "_y"] (Lit (LInt 1))
            @?=
            (["_y0", "_y1"], Lit (LInt 1))
    , testCase "changes param names which are similar to generated names and their users" $
        ensureUniqueNames ["_x", "_y"] 
            (Let [Def "_x" (Lit (LInt 1))] (Op Add (Var "_x") (Var "_y")))
            @?=
            (["_y0", "_y1"], Let [Def "_y2" (Lit (LInt 1))] (Op Add (Var "_y2") (Var "_y1")))
    ]

ensureNoUnusedDefsTests = testGroup "ensureNoUsedDefs tests"
    [ testCase "expressions with no unused defs are unchanged" $
        ensureNoUnusedDefs 
            (Let [ Def "x" (Lit (LInt 1))
                 , Def "y" (Lit (LInt 2))
                 ] 
                 (Let [ Def "z" (Lit (LInt 3))
                      , Def "w" (Lit (LInt 4))
                      ] (Op Add (Var "x") (Op Add (Var "y") (Op Add (Var "z") (Var "w"))))))
            @?=
            Let [ Def "x" (Lit (LInt 1))
                , Def "y" (Lit (LInt 2))
                ] 
                (Let [ Def "z" (Lit (LInt 3))
                     , Def "w" (Lit (LInt 4))
                     ] (Op Add (Var "x") (Op Add (Var "y") (Op Add (Var "z") (Var "w")))))
    , testCase "removes unused defs" $
        ensureNoUnusedDefs 
            (Let [ Def "x" (Lit (LInt 1))
                 , Def "y" (Lit (LInt 2))
                 ] 
                 (Let [ Def "z" (Lit (LInt 3))
                      , Def "w" (Lit (LInt 4))
                      ] (Op Add (Var "x") (Var "w"))))
            @?=
            Let [ Def "x" (Lit (LInt 1)) ] 
                (Let [ Def "w" (Lit (LInt 4)) ]
                    (Op Add (Var "x") (Var "w")))
    , testCase "removes let expressions if all expressions unused" $
        ensureNoUnusedDefs 
            (Let [ Def "x" (Lit (LInt 1))
                 , Def "y" (Lit (LInt 2))
                 ] 
                 (Let [ Def "z" (Lit (LInt 3))
                      , Def "w" (Lit (LInt 4))
                      ] (Lit (LInt 0))))
            @?= Lit (LInt 0)
    ]

defnWithBranch
    = Op Add (App (Var "foo") (Lit (LInt 1))) (App (Var "bar") (Lit (LInt 2)))
functionWithBranch
    = Just (["n"], defnWithBranch)
graphWithBranch
    = ( Map.fromList 
        [ ("_", Scope)
        , ("_x1", Expression (DApp "foo" [DLit (DInt 1)]))
        , ("_x2", Expression (DApp "bar" [DLit (DInt 2)]))
        , ("_x0", Expression (DOp Add (DVar "_x1") (DVar "_x2")))
        ]
      , Set.fromList
        [ ("_", "_x1", Dep)
        , ("_", "_x2", Dep)
        , ("_x1", "_x0", Dep)
        , ("_x2", "_x0", Dep)
        ]
      )

parallelisationTypeTests = testGroup "parallelisationType tests"
    [ testCase "never parallelise a function with no complexity annotation" $
        parallelisationType 1000 (Nothing, Just [Int, Int], functionWithBranch)
            @?= Never
    , testCase "never parallelise a function with no defn" $
        parallelisationType 1000 (Just (Polynomial "n" 2), Just [Int, Int], Nothing)
            @?= Never
    , testCase "always parallelise a function with constant time greater than steps" $
        parallelisationType 1000 (Just (Constant 1001), Just [Int, Int], functionWithBranch)
            @?= Always
    , testCase "never parallelise a function with constant time lower than steps" $
        parallelisationType 1000 (Just (Constant 999), Just [Int, Int], functionWithBranch)
            @?= Never
    , testCase "never parallelise a function with logarithmic time" $
        parallelisationType 1000 (Just (Logarithmic "n"), Nothing, functionWithBranch)
            @?= Never
    , testCase "branching parallelisation for linear time" $
        parallelisationType 100 (Just (Polynomial "n" 1), Nothing, functionWithBranch)
            @?= Branching (Op GT (Var "n") (Lit (LInt 100)))
    , testCase "branching parallelisation for quadratic time" $
        parallelisationType 100 (Just (Polynomial "n" 2), Nothing, functionWithBranch)
            @?= Branching (Op GT (Var "n") (Lit (LInt 10)))
    , testCase "branching parallelisation for exponential time" $
        parallelisationType 1000000 (Just (Exponential 2 "n"), Nothing, functionWithBranch)
            @?= Branching (Op GT (Var "n") (Lit (LInt 20)))
    , testCase "correct lhs for boundary in branching parallelisation for quadratic time" $
        parallelisationType 100 (Just (Polynomial "n" 2), Just [List Int, Int], functionWithBranch)
            @?= Branching (Op GT (App (Var "length") (Var "n")) (Lit (LInt 10)))
    ]

createEncodingInstructionTableTests = testGroup "createEncodingInstructionTable tests"
    [ testCase "ignores functions without definitions" $
        createEncodingInstructionTable 100 (Map.fromList
        [ ("foo", (Just (Polynomial "m" 1), Nothing, Nothing))
        , ("bar", (Just (Polynomial "q" 1), Just [Int, Int], Nothing))
        , ("baz", (Nothing, Just [Bool, Int, Int, Int, Int, Int], Nothing))
        ])
        @?= Map.empty
    , testCase "does not parallelise functions without complexity annotation" $
        createEncodingInstructionTable 100 (Map.fromList
        [ ("foo", (Nothing, Just [Int, Int], functionWithBranch))
        , ("bar", (Nothing, Nothing, functionWithBranch))
        ])
        @?= Map.fromList 
        [ ("foo", Sequential (Just [Int, Int]) ["n"] defnWithBranch)
        , ("bar", Sequential Nothing ["n"] defnWithBranch)
        ]
    , testCase "does not parallelise functions with low complexity" $
        createEncodingInstructionTable 100 (Map.fromList
        [ ("foo", (Just (Constant 50), Just [Int, Int], functionWithBranch))
        , ("bar", (Just (Constant 99), Nothing, functionWithBranch))
        , ("baz", (Just (Logarithmic "n"), Nothing, functionWithBranch))
        ])
        @?= Map.fromList 
        [ ("foo", Sequential (Just [Int, Int]) ["n"] defnWithBranch)
        , ("bar", Sequential Nothing ["n"] defnWithBranch)
        , ("baz", Sequential Nothing ["n"] defnWithBranch)
        ]
    , testCase "exclusively parallelises functions with high trivial complexity" $
        createEncodingInstructionTable 100 (Map.fromList
        [ ("foo", (Just (Constant 101), Just [Int, Int], functionWithBranch))
        , ("bar", (Just (Constant 10000000), Nothing, functionWithBranch))
        ])
        @?= Map.fromList 
        [ ("foo", Parallel (Just [Int, Int]) ["n"] graphWithBranch)
        , ("bar", Parallel Nothing ["n"] graphWithBranch)
        ]
    , testCase "parallelise functions with polynomial complexity" $
        createEncodingInstructionTable 100 (Map.fromList
        [ ("foo", (Just (Polynomial "n" 2), Just [Int, Int], functionWithBranch))
        , ("bar", (Just (Polynomial "n" 1), Nothing, functionWithBranch))
        ])
        @?= Map.fromList 
        [ ("foo", Sequential (Just [Int, Int]) ["n"] 
                    (If (Op GT (Var "n") (Lit (LInt 10))) 
                        (App (Var "foo_par") (Var "n"))
                        (App (Var "foo_seq") (Var "n")) 
                    ))
        , ("foo_seq", Sequential (Just [Int, Int]) ["n"] defnWithBranch)
        , ("foo_par", Parallel (Just [Int, Int]) ["n"] graphWithBranch)
        , ("bar", Sequential Nothing ["n"] 
                    (If (Op GT (Var "n") (Lit (LInt 100))) 
                        (App (Var "bar_par") (Var "n"))
                        (App (Var "bar_seq") (Var "n")) 
                    ))
        , ("bar_seq", Sequential Nothing ["n"] defnWithBranch)
        , ("bar_par", Parallel Nothing ["n"] graphWithBranch)
        ]
    ]

createDependencyGraphTests = testGroup "createDependencyGraph test"
    [ testCase "create very basic graph" $
        createDependencyGraph [] (Lit (LInt 1))
            @?= ( Map.fromList 
                    [ ("_", Scope)
                    , ("_x0", Expression (DLit (DInt 1)))
                    ]
                , Set.fromList [("_", "_x0", Dep)]
                )
    , testCase "create very basic graph with argument" $
        createDependencyGraph ["n"] (Var "n")
            @?= ( Map.fromList 
                    [("_", Scope), ("_x0", Expression (DVar "n"))]
                , Set.fromList 
                    [("_", "_x0", Dep), ("_", "_x0", DepParam)]
                )
    , testCase "create atomic binary operation graph" $
        createDependencyGraph ["n"] (Op Add (Op Add (Lit (LInt 1)) (Lit (LInt 2))) (Lit (LInt 3)))
            @?= ( Map.fromList 
                    [ ("_", Scope)
                    , ("_x0", Expression (DOp Add (DOp Add (DLit (DInt 1)) (DLit (DInt 2))) (DLit (DInt 3))))
                    ]
                , Set.fromList [("_", "_x0", Dep)]
                )
    , testCase "create binary operation graph" $
        createDependencyGraph ["n"] (Op Add (Var "n") (Lit (LInt 3)))
            @?= ( Map.fromList 
                    [ ("_", Scope)
                    , ("_x0", Expression (DOp Add (DVar "n") (DLit (DInt 3))))
                    ]
                , Set.fromList [("_", "_x0", Dep), ("_", "_x0", DepParam)]
                )
    , testCase "create function application graph" $
        createDependencyGraph ["n"] (App (App (Var "someFunc") (Var "n")) (Op Add (Lit (LInt 1)) (Lit (LInt 1))))
            @?= ( Map.fromList 
                    [ ("_", Scope)
                    , ("_x0", Expression (DApp "someFunc" [DVar "n", DOp Add (DLit (DInt 1)) (DLit (DInt 1))]))
                    ]
                , Set.fromList [("_", "_x0", Dep), ("_", "_x0", DepParam)]
                )
    , testCase "create let graph" $
        createDependencyGraph ["n"] 
            (Let [ Def "a" (Lit (LInt 1))
                 , Def "b" (Lit (LInt 2))
                 ] 
                 (Op Add (Var "a") (Var "n"))
            )
            @?= ( Map.fromList 
                    [ ("_", Scope)
                    , ("a", Expression (DLit (DInt 1)))
                    , ("b", Expression (DLit (DInt 2)))
                    , ("_x0", Expression (DOp Add (DVar "a") (DVar "n")))
                    ]
                , Set.fromList 
                    [ ("_", "_x0", DepParam)
                    , ("a", "_x0", Dep)
                    , ("_", "a", Dep)
                    , ("_", "b", Dep)
                    ]
                )
    , testCase "create if graph" $
        createDependencyGraph ["a", "b"] 
            (If (Op LT (Var "a") (Lit (LInt 1)))
                (Lit (LInt 2))
                (App (Var "foobar") (Op Add (Var "a") (Var "b")))
            )
            @?= ( Map.fromList 
                    [ ("_", Scope)
                    , ("_x0", Conditional (DOp LT (DVar "a") (DLit (DInt 1))))
                    , ("_1", Scope)
                    , ("_x2", Expression (DLit (DInt 2)))
                    , ("_3", Scope)
                    , ("_x4", Expression (DApp "foobar" [DOp Add (DVar "a") (DVar "b")]))
                    ]
                , Set.fromList 
                    [ ("_", "_x0", Dep)
                    , ("_", "_x0", DepParam)
                    , ("_x0", "_1", DepThen)
                    , ("_x0", "_3", DepElse)
                    , ("_1", "_x2", Dep)
                    , ("_3", "_x4", Dep)
                    , ("_", "_x4", DepParam)
                    ]
                )
            
    ]